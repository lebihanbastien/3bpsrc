function [tmdn, ymdn, yma] = diff_corr_2levels(tmd, ymd, N2, dcs, inputType, isTimeFixed)

%--------------------------------------------------------------------------
% Copy the departure state
%--------------------------------------------------------------------------
tmdn = tmd;
ymdn = ymd;

%--------------------------------------------------------------------------
% Copy the departure state
%--------------------------------------------------------------------------
normC = 1e5;
iter = 0;
while(normC > 1e-12 && iter < 50)
    %----------------------------------------------------------------------
    % Arrival state
    %----------------------------------------------------------------------
    yma = zeros(N2, 42);
    yma(1, :) = ymdn(1,:);
    
    %----------------------------------------------------------------------
    % Level one
    %----------------------------------------------------------------------
    for k = 1:N2-1
        %------------------------------------------------------------------
        % Integration
        %------------------------------------------------------------------
        [tm, ym] = ode78_qbcp([tmdn(k) tmdn(k+1)], ymdn(k,:), dcs, 1, inputType, inputType);
        
        %------------------------------------------------------------------
        % Final position is at the end of ym
        %------------------------------------------------------------------
        ye = ym(end,:)';
        te = tm(end);
        
        %------------------------------------------------------------------
        % Arrival state
        %------------------------------------------------------------------
        yma(k+1, 1:6) = ye(1:6);
        yma(k+1,7:42) = ymdn(1,7:42); %set identity matrix in yma!!
        
        %------------------------------------------------------------------
        % Update the Jacobian
        %------------------------------------------------------------------
        % STM
        STM = vectorToMatrix(ye, 6, 6, 6);
        % Derivatives at tf
        yedot = qbcp_vfn_novar(te, ye(1:6), dcs)';
        % Jacobian
        if(isTimeFixed)
            L = STM(1:3,4:6);
        else
            L = [STM(1:3,4:6) yedot(1:3)];
        end

        
        %------------------------------------------------------------------
        % Update the error vector
        %------------------------------------------------------------------
        b = ye(1:3) - ymdn(k+1,1:3)';

        %------------------------------------------------------------------
        % Norm
        %------------------------------------------------------------------
        normC = norm(b);
        fprintf('normC = %5.15e\n', normC);
        
        %------------------------------------------------------------------
        % Minimum norm solution
        %------------------------------------------------------------------
        if(isTimeFixed)
            kv = L \ b;
        else
            kv = L'*(L*L'\b);
        end

        %------------------------------------------------------------------
        % Update the free variable
        %------------------------------------------------------------------
        ymdn(k,4:6) = ymdn(k, 4:6) - kv(1:3)';
        if(~isTimeFixed)
            tmdn(k+1)   = tmdn(k+1) - kv(4);
        end
    end

end

fprintf('---------------------------------------------------\n');
fprintf('Level II\n');
fprintf('---------------------------------------------------\n');

%--------------------------------------------------------------------------
% Level two
%--------------------------------------------------------------------------
normC = 1e5;
iter = 0;
while(normC > 1e-12 && iter < 1)
    %----------------------------------------------------------------------
    % Initialize the super matrix & the error vector
    %----------------------------------------------------------------------
    % Number of inner points
    ni = N2-2;
    % Initialization
    Ms = zeros(3*ni, 12*ni + 4*(ni-1));
    dv = zeros(3*ni, 1);
    
    %----------------------------------------------------------------------
    % Level two
    %----------------------------------------------------------------------
    for k = 1:N2-2 %only the inner points!
        %------------------------------------------------------------------
        % Forward integration from k to k+1
        %------------------------------------------------------------------
        [tm, ym] = ode78_qbcp([tmdn(k) tmdn(k+1)], ymdn(k,:), dcs, 1, inputType, inputType);
        
        % Final state
        ypa = ym(end,:)';
        tpa = tm(end);
        % STM
        STMa = vectorToMatrix(ypa, 6, 6, 6);
        % Derivatives at tf
        ypadot = qbcp_vfn_novar(tpa, ypa(1:6), dcs)';
        
        %------------------------------------------------------------------
        % Backward integration from k+2 to k+1
        %------------------------------------------------------------------
        [tm, ym] = ode78_qbcp([tmdn(k+2) tmdn(k+1)], yma(k+2,:), dcs, 1, inputType, inputType);
        
        % Final state
        ypd = ym(end,:)';
        tpd = tm(end);
        % STM
        STMd = vectorToMatrix(ypd, 6, 6, 6);
        % Derivatives at tf
        ypddot = qbcp_vfn_novar(tpd, ypd(1:6), dcs)';
        
        %------------------------------------------------------------------
        % Level II matrices
        %------------------------------------------------------------------
        M0  = STMa(4:6,4:6)*inv(STMa(1:3,4:6))*STMa(1:3, 1:3) - STMa(4:6,1:3);
        Mt0 = ypadot(4:6) - STMa(4:6,4:6)*inv(STMa(1:3,4:6))*ypadot(1:3);
        Mp  = STMd(4:6,4:6)*inv(STMd(1:3,4:6)) - STMa(4:6,4:6)*inv(STMa(1:3,4:6));
        Mtp = STMa(4:6,4:6)*inv(STMa(1:3,4:6))*ypadot(1:3) - ypadot(4:6) - STMd(4:6,4:6)*inv(STMd(1:3,4:6))*ypddot(1:3) + ypddot(4:6);
        Mf  = STMd(4:6,1:3) - STMd(4:6,4:6)*inv(STMd(1:3,4:6))*STMd(1:3, 1:3);
        Mtf = STMd(4:6,4:6)*inv(STMd(1:3,4:6))*ypddot(1:3) - ypddot(4:6);
        
        
        %------------------------------------------------------------------
        % Update the super matrix
        %------------------------------------------------------------------
        kl = 3*(k-1);
        kc = 4*(k-1);
        
        Ms(1+kl:3+kl, 1+kc:3+kc) = M0;
        Ms(1+kl:3+kl, 4+kc) = Mt0;
        
        Ms(1+kl:3+kl, 5+kc:7+kc) = Mp;
        Ms(1+kl:3+kl, 8+kc) = Mtp;
        
        Ms(1+kl:3+kl, 9+kc:11+kc) = Mf;
        Ms(1+kl:3+kl, 12+kc) = Mtf;
        
        %------------------------------------------------------------------
        % Update the error vector
        %------------------------------------------------------------------
        dv(1+kl:3+kl) = ypd(4:6) - ypa(4:6);
    end
    
    fprintf('yma(2,4:6) = %5.5f\n', yma(2,4:6));
    fprintf('ypa = %5.5f\n', ypa(4:6));
    
    fprintf('ymdn(2,4:6) = %5.5f\n', ymdn(2,4:6));
    fprintf('ypd = %5.5f\n', ypd(4:6));
    
    %----------------------------------------------------------------------
    % Inverse the level II system
    %----------------------------------------------------------------------
    dr = Ms'*(Ms*Ms'\dv);
    
    %----------------------------------------------------------------------
    % Norm
    %----------------------------------------------------------------------
    normC = norm(dv);
    fprintf('normC = %5.15e\n', normC);
    
    
    %----------------------------------------------------------------------
    % Update the state
    %----------------------------------------------------------------------   
    %Inner points
    for k = 0:N2-1
        kc = 4*k;
        ymdn(k+1,4:6) = ymdn(k+1, 4:6) + dr(1+kc:3+kc)';
        tmdn(k+1)     = tmdn(k+1)      + dr(4+kc);
    end

    
    
    %----------------------------------------------------------------------
    % Update number of iterations
    %----------------------------------------------------------------------
    iter = iter + 1;
    
end

end

