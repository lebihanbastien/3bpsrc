<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN"
                "http://www.w3.org/TR/REC-html40/loose.dtd">
<html>
<head>
  <title>Description of diff_corr_3D_full</title>
  <meta name="keywords" content="diff_corr_3D_full">
  <meta name="description" content="DIFF_CORR_3D_FULL Differential correction to compute for 3D periodic">
  <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
  <meta name="generator" content="m2html v1.5 &copy; 2003-2005 Guillaume Flandin">
  <meta name="robots" content="index, follow">
  <link type="text/css" rel="stylesheet" href="../m2html.css">
</head>
<body>
<a name="_top"></a>
<div><a href="../index.html">Home</a> &gt;  <a href="index.html">diffcorr</a> &gt; diff_corr_3D_full.m</div>

<!--<table width="100%"><tr><td align="left"><a href="../index.html"><img alt="<" border="0" src="../left.png">&nbsp;Master index</a></td>
<td align="right"><a href="index.html">Index for diffcorr&nbsp;<img alt=">" border="0" src="../right.png"></a></td></tr></table>-->

<h1>diff_corr_3D_full
</h1>

<h2><a name="_name"></a>PURPOSE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>DIFF_CORR_3D_FULL Differential correction to compute for 3D periodic</strong></div>

<h2><a name="_synopsis"></a>SYNOPSIS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="box"><strong>function orbit = diff_corr_3D_full(v0, cr3bp , orbit, params, cst) </strong></div>

<h2><a name="_description"></a>DESCRIPTION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre class="comment"> DIFF_CORR_3D_FULL Differential correction to compute for 3D periodic 
 orbits of the CRTBP symmetric, with respect to the xz-plane (halo, 
 vertical).

 This differential corrector is heavily based on the summary by Pavlak in
 his PhD thesis (2013), although the basic principles are much older than
 his work.

 This routines iteratively correct the initial state v0 via an iterative
 Newton method.
 Given the free variables X0:
       X0 = [x0 z0 vy0 T12]^T, with vy0 = dot(y0), T12 = half period,

 given the targeted constraint FX = F(X) = [y vx vz]^T = 0,

 the correction dX0 to be applied to X0 satisfies the following equation:
           FX = DFX*dX0 (1)
 with - FX = [y vx vz]^T,
      - DFX the matrix defined as the Jacobian: DFX = dF(X)/dX0

 More precisely:

   DFX = | Phi21   Phi23  Phi25  vy |
          | Phi41   Phi43  Phi45  ax |
         | Phi61   Phi63  Phi65  az |

   with vy = dot(y), ax = dot(vx) = dot(dot(x)), same for az.
   and where Phi is the State Transition Matrix (STM), numerically
   integrated along with the state.

  The system (1), infradetermined. The minimum norm solution is chosen
  here:
           dX0 = DFX' * inv(DFX * DFX') * FX;

 At the end of the routine, the following elements are updated:
 - orbit.y0:         initial conditions.
 - orbit.T12:        half period.
 - orbit.T:          period.
 - orbit.cont.gv:    final vector of free variables for a potential continuation procedure.
 - orbit.cont.nv:    null vector of the Jacobian for a potential continuation procedure.

 BLB 2016.</pre></div>

<!-- crossreference -->
<h2><a name="_cross"></a>CROSS-REFERENCE INFORMATION <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
This function calls:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
This function is called by:
<ul style="list-style-image:url(../matlabicon.gif)">
</ul>
<!-- crossreference -->

<h2><a name="_subfunctions"></a>SUBFUNCTIONS <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<ul style="list-style-image:url(../matlabicon.gif)">
<li><a href="#_sub1" class="code">function shiftedIndix = findIndix(i0, j0)</a></li><li><a href="#_sub2" class="code">function [] = plotDiffCorr(yv, cr3bp, iter)</a></li></ul>

<h2><a name="_source"></a>SOURCE CODE <a href="#_top"><img alt="^" border="0" src="../up.png"></a></h2>
<div class="fragment"><pre>0001 <a name="_sub0" href="#_subfunctions" class="code">function orbit = diff_corr_3D_full(v0, cr3bp , orbit, params, cst)</a>
0002 <span class="comment">% DIFF_CORR_3D_FULL Differential correction to compute for 3D periodic</span>
0003 <span class="comment">% orbits of the CRTBP symmetric, with respect to the xz-plane (halo,</span>
0004 <span class="comment">% vertical).</span>
0005 <span class="comment">%</span>
0006 <span class="comment">% This differential corrector is heavily based on the summary by Pavlak in</span>
0007 <span class="comment">% his PhD thesis (2013), although the basic principles are much older than</span>
0008 <span class="comment">% his work.</span>
0009 <span class="comment">%</span>
0010 <span class="comment">% This routines iteratively correct the initial state v0 via an iterative</span>
0011 <span class="comment">% Newton method.</span>
0012 <span class="comment">% Given the free variables X0:</span>
0013 <span class="comment">%       X0 = [x0 z0 vy0 T12]^T, with vy0 = dot(y0), T12 = half period,</span>
0014 <span class="comment">%</span>
0015 <span class="comment">% given the targeted constraint FX = F(X) = [y vx vz]^T = 0,</span>
0016 <span class="comment">%</span>
0017 <span class="comment">% the correction dX0 to be applied to X0 satisfies the following equation:</span>
0018 <span class="comment">%           FX = DFX*dX0 (1)</span>
0019 <span class="comment">% with - FX = [y vx vz]^T,</span>
0020 <span class="comment">%      - DFX the matrix defined as the Jacobian: DFX = dF(X)/dX0</span>
0021 <span class="comment">%</span>
0022 <span class="comment">% More precisely:</span>
0023 <span class="comment">%</span>
0024 <span class="comment">%   DFX = | Phi21   Phi23  Phi25  vy |</span>
0025 <span class="comment">%          | Phi41   Phi43  Phi45  ax |</span>
0026 <span class="comment">%         | Phi61   Phi63  Phi65  az |</span>
0027 <span class="comment">%</span>
0028 <span class="comment">%   with vy = dot(y), ax = dot(vx) = dot(dot(x)), same for az.</span>
0029 <span class="comment">%   and where Phi is the State Transition Matrix (STM), numerically</span>
0030 <span class="comment">%   integrated along with the state.</span>
0031 <span class="comment">%</span>
0032 <span class="comment">%  The system (1), infradetermined. The minimum norm solution is chosen</span>
0033 <span class="comment">%  here:</span>
0034 <span class="comment">%           dX0 = DFX' * inv(DFX * DFX') * FX;</span>
0035 <span class="comment">%</span>
0036 <span class="comment">% At the end of the routine, the following elements are updated:</span>
0037 <span class="comment">% - orbit.y0:         initial conditions.</span>
0038 <span class="comment">% - orbit.T12:        half period.</span>
0039 <span class="comment">% - orbit.T:          period.</span>
0040 <span class="comment">% - orbit.cont.gv:    final vector of free variables for a potential continuation procedure.</span>
0041 <span class="comment">% - orbit.cont.nv:    null vector of the Jacobian for a potential continuation procedure.</span>
0042 <span class="comment">%</span>
0043 <span class="comment">% BLB 2016.</span>
0044 
0045 <span class="comment">%--------------------------------------------------------------------------</span>
0046 <span class="comment">%Iteration counts</span>
0047 <span class="comment">%--------------------------------------------------------------------------</span>
0048 iter = 0;
0049 
0050 <span class="comment">%--------------------------------------------------------------------------</span>
0051 <span class="comment">% Get an estimate of the half period if it is not provided</span>
0052 <span class="comment">%--------------------------------------------------------------------------</span>
0053 <span class="keyword">if</span>(isfield(orbit, <span class="string">'T12'</span>))
0054     T12 = orbit.T12;
0055 <span class="keyword">else</span>
0056     <span class="comment">%----------------------------------------------------------------------</span>
0057     <span class="comment">% If the half period is not provided from a previous computation, the</span>
0058     <span class="comment">% following code intent to compute an estimate of the half period by</span>
0059     <span class="comment">% integrating the equations of motion until the symmetry plane of the</span>
0060     <span class="comment">% orbit is reached.</span>
0061     <span class="comment">%</span>
0062     <span class="comment">% For example, for an halo orbit, the equations of motion should be</span>
0063     <span class="comment">% integrated until the plane y = 0 is reached.</span>
0064     <span class="comment">%----------------------------------------------------------------------</span>
0065     disp( <span class="string">'diff_corr_3D_full. No half period estimate was provided.'</span>);
0066     disp([<span class="string">'diff_corr_3D_full. An approximation of the half period.'</span>,<span class="keyword">...</span>
0067         <span class="string">'is computed from a numerical integration until the'</span>,<span class="keyword">...</span>
0068         <span class="string">'symmetry plane of the orbit is reached.'</span>]);
0069     <span class="comment">%----------------------------------------------------------------------</span>
0070     <span class="comment">% Numerical integration with ode113</span>
0071     <span class="comment">%----------------------------------------------------------------------</span>
0072     options = odeset(<span class="string">'Events'</span>, @odezero_y,<span class="string">'Reltol'</span>, params.ode45.RelTol, <span class="string">'Abstol'</span>, params.ode45.AbsTol);
0073     [~,~,T12] = ode113(@(t,y)cr3bp_derivatives_6(t,y,cr3bp.mu),[0 10],v0(1:6),options);
0074 <span class="keyword">end</span>
0075 
0076 <span class="comment">%--------------------------------------------------------------------------</span>
0077 <span class="comment">% Update the options: no event is necessary after this point.</span>
0078 <span class="comment">%--------------------------------------------------------------------------</span>
0079 <span class="keyword">if</span>(params.computation.type == cst.computation.MATLAB)
0080     options = odeset(<span class="string">'Reltol'</span>, params.ode45.RelTol, <span class="string">'Abstol'</span>, params.ode45.AbsTol);
0081 <span class="keyword">end</span>
0082 
0083 <span class="comment">%--------------------------------------------------------------------------</span>
0084 <span class="comment">% Differential correction loop</span>
0085 <span class="comment">%--------------------------------------------------------------------------</span>
0086 <span class="keyword">while</span>(true)
0087     iter = iter+1;
0088     <span class="comment">%----------------------------------------------------------------------</span>
0089     <span class="comment">%Stops if too much iterations</span>
0090     <span class="comment">%----------------------------------------------------------------------</span>
0091     <span class="keyword">if</span>(iter &gt; 50)
0092         disp(<span class="string">'WARNING: maximum iterations reached in differential_correction'</span>);
0093         <span class="keyword">break</span>;
0094     <span class="keyword">end</span>
0095     
0096     <span class="comment">%----------------------------------------------------------------------</span>
0097     <span class="comment">% Integration stops at t = T12</span>
0098     <span class="comment">%----------------------------------------------------------------------</span>
0099     <span class="keyword">if</span>(params.computation.type == cst.computation.MATLAB)
0100         <span class="comment">%-----------------------------</span>
0101         <span class="comment">% If MATLAB routines only</span>
0102         <span class="comment">%-----------------------------</span>
0103         [t,yv] = ode113(@(t,y)cr3bp_derivatives_42(t,y,cr3bp.mu),[0 T12],v0,options);
0104         <span class="comment">% Update final state</span>
0105         te = t(end);
0106         ve = yv(<span class="keyword">end</span>,:);
0107     <span class="keyword">else</span>
0108         <span class="comment">%-----------------------------</span>
0109         <span class="comment">% If MEX routines are allowed</span>
0110         <span class="comment">%-----------------------------</span>
0111         <span class="keyword">if</span>(params.plot.diff_corr == 1)
0112             [te, ve, ~, yv] = ode78_cr3bp(0.0, T12, v0, 42, cr3bp.mu);
0113         <span class="keyword">else</span>
0114             [te, ve] = ode78_cr3bp(0.0, T12, v0, 42, cr3bp.mu);
0115         <span class="keyword">end</span>
0116     <span class="keyword">end</span>
0117     
0118     <span class="comment">%----------------------------------------------------------------------</span>
0119     <span class="comment">% Update the final state: FX = [y vx vz]^T.</span>
0120     <span class="comment">%----------------------------------------------------------------------</span>
0121     FX = [ve(2) ; ve(4) ; ve(6)];
0122     
0123     <span class="comment">%----------------------------------------------------------------------</span>
0124     <span class="comment">% Compute the first order correction with Newton's method:</span>
0125     <span class="comment">% Targeting the constraint FX = F(X) = 0, with the free variables X0,</span>
0126     <span class="comment">% The correction dX0 to applied to these variables satisfies the</span>
0127     <span class="comment">% equation:</span>
0128     <span class="comment">%           FX = DFX*dX0</span>
0129     <span class="comment">% With DFX the matrix defined as the Jacobian:</span>
0130     <span class="comment">%           DFX = dF(X)/dX0</span>
0131     <span class="comment">% In our case, the free variables are:</span>
0132     <span class="comment">%           X0 = [x0 z0 vy0 T12]^T</span>
0133     <span class="comment">%----------------------------------------------------------------------</span>
0134     <span class="comment">% Build the Jacobian DFX = dF(X)/dX0, with X0 = [x0, z0, vy0 T12]^T</span>
0135     <span class="comment">%</span>
0136     <span class="comment">%   DFX = | Phi21   Phi23  Phi25  vy |</span>
0137     <span class="comment">%          | Phi41   Phi43  Phi45  ax |</span>
0138     <span class="comment">%         | Phi61   Phi63  Phi65  az |</span>
0139     <span class="comment">%</span>
0140     <span class="comment">%   with vy = dot(y), ax = dot(vx) = dot(dot(x)), same for az.</span>
0141     <span class="comment">%   and where Phi is the State Transition Matrix (STM).</span>
0142     <span class="comment">%----------------------------------------------------------------------</span>
0143     DFX = zeros(3,4);
0144     
0145     <span class="comment">% Concatenate the elements of the STM.</span>
0146     DFX(1,1) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(2,1));
0147     DFX(1,2) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(2,3));
0148     DFX(1,3) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(2,5));
0149     
0150     DFX(2,1) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(4,1));
0151     DFX(2,2) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(4,3));
0152     DFX(2,3) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(4,5));
0153     
0154     DFX(3,1) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(6,1));
0155     DFX(3,2) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(6,3));
0156     DFX(3,3) = ve(<a href="#_sub1" class="code" title="subfunction shiftedIndix = findIndix(i0, j0)">findIndix</a>(6,5));
0157     
0158     <span class="comment">%Last column is [vy ax az]^T</span>
0159     vep = cr3bp_derivatives_6(te, ve, cr3bp.mu);
0160     DFX(1,4) = vep(2);
0161     DFX(2,4) = vep(4);
0162     DFX(3,4) = vep(6);
0163     
0164     <span class="comment">%----------------------------------------------------------------------</span>
0165     <span class="comment">% Stops if precision is good enough, but after the Jacobian has been</span>
0166     <span class="comment">% built, so that it is updated at the end.</span>
0167     <span class="comment">%----------------------------------------------------------------------</span>
0168     <span class="keyword">if</span>(norm(FX) &lt; params.diff_corr.precision);
0169         <span class="keyword">break</span>;
0170     <span class="keyword">end</span>
0171     
0172     <span class="comment">%----------------------------------------------------------------------</span>
0173     <span class="comment">% The first order correction is computed as the minimum norm solution</span>
0174     <span class="comment">%----------------------------------------------------------------------</span>
0175     dX0 = DFX' * ( (DFX * DFX') \ FX);
0176     
0177     <span class="comment">%----------------------------------------------------------------------</span>
0178     <span class="comment">% Updating the initial state</span>
0179     <span class="comment">%----------------------------------------------------------------------</span>
0180     v0(1) = v0(1) - dX0(1);
0181     v0(3) = v0(3) - dX0(2);
0182     v0(5) = v0(5) - dX0(3);
0183     T12    = T12    - dX0(4);
0184     
0185     <span class="comment">%----------------------------------------------------------------------</span>
0186     <span class="comment">% Plotting (potentially)</span>
0187     <span class="comment">%----------------------------------------------------------------------</span>
0188     <span class="keyword">if</span>(params.plot.diff_corr == 1)
0189         <a href="#_sub2" class="code" title="subfunction [] = plotDiffCorr(yv, cr3bp, iter)">plotDiffCorr</a>(yv, cr3bp, iter);
0190     <span class="keyword">end</span>
0191 <span class="keyword">end</span>
0192 
0193 <span class="comment">%--------------------------------------------------------------------------</span>
0194 <span class="comment">% Orbit update</span>
0195 <span class="comment">%--------------------------------------------------------------------------</span>
0196 orbit.y0  = v0;
0197 orbit.T12 = T12;   <span class="comment">%1/2 period</span>
0198 orbit.T   = 2*T12; <span class="comment">%period</span>
0199 
0200 <span class="comment">%--------------------------------------------------------------------------</span>
0201 <span class="comment">% Compute the final vector of free variables for a potential continuation</span>
0202 <span class="comment">% procedure.</span>
0203 <span class="comment">%--------------------------------------------------------------------------</span>
0204 orbit.cont.gv = [v0(1) ; v0(3) ; v0(5) ; T12];
0205 
0206 <span class="comment">%--------------------------------------------------------------------------</span>
0207 <span class="comment">% Compute the null vector of the Jacobian for a potential continuation</span>
0208 <span class="comment">% procedure.</span>
0209 <span class="comment">%--------------------------------------------------------------------------</span>
0210 orbit.cont.nv = -null(DFX);
0211 
0212 <span class="keyword">end</span>
0213 
0214 <span class="comment">%--------------------------------------------------------------------------</span>
0215 <span class="comment">% Return the right indix to find Phi(i0, j0) in ve</span>
0216 <span class="comment">%--------------------------------------------------------------------------</span>
0217 <a name="_sub1" href="#_subfunctions" class="code">function shiftedIndix = findIndix(i0, j0)</a>
0218 shiftedIndix = 6 + 6*(i0-1)+j0;
0219 <span class="keyword">end</span>
0220 
0221 <span class="comment">%--------------------------------------------------------------------------</span>
0222 <span class="comment">% Plotting the iterations</span>
0223 <span class="comment">%--------------------------------------------------------------------------</span>
0224 <a name="_sub2" href="#_subfunctions" class="code">function [] = plotDiffCorr(yv, cr3bp, iter)</a>
0225     figure(1)
0226     <span class="keyword">if</span>(iter==1)
0227         plot(yv(:,1)*cr3bp.L,yv(:,2)*cr3bp.L, <span class="string">'g'</span>);
0228     <span class="keyword">else</span>
0229         plot(yv(:,1)*cr3bp.L,yv(:,2)*cr3bp.L, <span class="string">'r'</span>);
0230     <span class="keyword">end</span>
0231     hold on
0232     xlabel(<span class="string">'X (km)'</span>)
0233     ylabel(<span class="string">'Y (km)'</span>)
0234     axis equal
0235     grid on
0236     title(<span class="string">'Halo orbit in X-Y plane'</span>);
0237 <span class="keyword">end</span></pre></div>
<hr><address>Generated on Sat 09-Apr-2016 16:20:23 by <strong><a href="http://www.artefact.tk/software/matlab/m2html/" title="Matlab Documentation in HTML">m2html</a></strong> &copy; 2005</address>
</body>
</html>